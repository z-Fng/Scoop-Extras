name: Check and Fix GitHub Redirects

on:
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * *'  # Daily at 00:00 UTC

jobs:
  fix-github-redirects:
    name: Check and Fix GitHub  Redirects
    runs-on: windows-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@main
        with:
          path: my_bucket

      - name: Check GitHub Repository Redirects
        shell: pwsh
        working-directory: my_bucket
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $repoSet = [System.Collections.Generic.HashSet[string]]::new()

          Get-ChildItem 'bucket' -Filter '*.json' -File | ForEach-Object {
            $content = Get-Content $_.FullName -Raw
            # Match only:
            # 1. https?://github.com/<owner>/<repo>
            # 2. https?://api.github.com/repos/<owner>/<repo>
            $matchResult = $content | Select-String -Pattern 'https?://(api\.github\.com/repos/|github\.com/)([^/"\s]+)/([^/"\s]+?)(?=\.git(?:[/?#]|$)|[/?#]|$)' -AllMatches
            if ($matchResult) {
              $matchResult.Matches | ForEach-Object {
                $owner = $_.Groups[2].Value
                $repo = $_.Groups[3].Value
                $repoSet.Add("$owner/$repo") | Out-Null
              }
            }
          }

          Write-Host "Found $($repoSet.Count) unique GitHub repositories.`n"

          # GitHub token from environment
          $token = $env:GITHUB_TOKEN
          if ($token) {
              Write-Host "Using GitHub GraphQL API with authentication."
          } else {
              Write-Host "Error: GITHUB_TOKEN not found."
              exit 1
          }

          $repoList = @($repoSet.GetEnumerator() | ForEach-Object { $_ })
          $redirects = @{}
          $unreachable = @()

          # Split into batches of 100 repos (GraphQL limit)
          $batchSize = 100
          $batches = [Math]::Ceiling($repoList.Count / $batchSize)

          Write-Host "Checking in $batches batches of $batchSize repos each.`n"

          for ($batch = 0; $batch -lt $batches; $batch++) {
              $start = $batch * $batchSize
              $end = [Math]::Min($start + $batchSize - 1, $repoList.Count - 1)
              $currentBatch = $repoList[$start..$end]

              # Build GraphQL query with aliases
              $queryParts = @("query {")
              $repoIndex = 0

              foreach ($repo in $currentBatch) {
                  $parts = $repo -split '/'
                  $owner = $parts[0]
                  $name = $parts[1]
                  $alias = "repo$repoIndex"
                  $queryParts += "  $($alias): repository(owner: `"$owner`", name: `"$name`") { owner { login } name }"
                  $repoIndex++
              }

              $queryParts += "}"
              $graphqlQuery = $queryParts -join "`n"

              try {
                  $headers = @{
                      "Authorization" = "Bearer $token"
                      "Accept" = "application/vnd.github.v3+json"
                  }

                  $body = @{
                      query = $graphqlQuery
                  } | ConvertTo-Json

                  Write-Host "Processing batch $($batch + 1)/$batches, repos $($start + 1)-$($end + 1)..."

                  $response = Invoke-WebRequest -Uri "https://api.github.com/graphql" -Method Post -Headers $headers -Body $body -TimeoutSec 30
                  $data = $response.Content | ConvertFrom-Json

                  # Get rate limit info from response headers
                  $rateLimitUsed = $response.Headers['X-RateLimit-Used']
                  $rateLimitLimit = $response.Headers['X-RateLimit-Limit']
                  $rateLimitRemaining = $response.Headers['X-RateLimit-Remaining']

                  Write-Host "  Rate Limit: $rateLimitUsed of $rateLimitLimit requests used ($rateLimitRemaining remaining)."

                  # Check each repository response
                  $repoIndex = 0
                  foreach ($repo in $currentBatch) {
                      $alias = "repo$repoIndex"
                      $result = $data.data.$alias

                      if ($result) {
                          $actualRepo = "$($result.owner.login)/$($result.name)"

                          # Check if it was redirected (requested repo != actual repo)
                          if ($actualRepo -ne $repo) {
                              $oldUrl = "https://github.com/$repo"
                              $newUrl = "https://github.com/$actualRepo"
                              $redirectKey = "$oldUrl -> $newUrl"
                              $redirects[$redirectKey] = ++$redirects[$redirectKey]
                              Write-Host "  ✓ Found: $redirectKey"
                          }
                      } else {
                          # GraphQL returned null - repo is gone
                          $unreachable += $repo
                          Write-Host "  ✗ Unreachable: https://github.com/$repo"
                      }

                      $repoIndex++
                  }
              } catch {
                  Write-Host "  Error in batch $($batch + 1): $($_.Exception.Message)"
              }

              # Add delay between batches to avoid rate limiting
              Start-Sleep -Seconds 2
          }

          Write-Host "`n=== Checked: $($repoList.Count) repositories ==="
          Write-Host "=== Found: $($redirects.Count) redirects, $($unreachable.Count) unreachable ===`n"

          if ($redirects.Count -gt 0) {
            Write-Host "=== Redirect Details ==="
            $redirects.GetEnumerator() | ForEach-Object {
              Write-Host "  $($_.Key)"
            }
          }

          if ($unreachable.Count -gt 0) {
            Write-Host "`n=== Unreachable Repositories ==="
            $unreachable | ForEach-Object {
              Write-Host "  https://github.com/$_"
            }
          }

          # Save redirects to file (only if there are any)
          if ($redirects.Count -gt 0) {
            $redirects | ConvertTo-Json | Out-File -FilePath "../redirects.json" -Encoding UTF8
            Write-Host "Redirects saved to: redirects.json"
          } else {
            if (Test-Path "../redirects.json") { Remove-Item "../redirects.json" }
            Write-Host "No redirects to save."
          }

          # Save unreachable to file (only if there are any)
          if ($unreachable.Count -gt 0) {
            $unreachable | ConvertTo-Json | Out-File -FilePath "../unreachable.json" -Encoding UTF8
            Write-Host "Unreachable saved to: unreachable.json"
          } else {
            if (Test-Path "../unreachable.json") { Remove-Item "../unreachable.json" }
            Write-Host "No unreachable repos to save."
          }

      - name: Apply redirects to manifests
        shell: pwsh
        working-directory: my_bucket
        run: |
          $redirectsFile = "../redirects.json"
          if (Test-Path $redirectsFile) {
            Write-Host "Loading redirects from: $redirectsFile..."
            $redirects = Get-Content $redirectsFile | ConvertFrom-Json
          } else {
            Write-Host "No redirects file found. Skipping manifest updates."
            exit 0
          }
          $changedFiles = @{}

          Write-Host "Applying redirects to bucket files...`n"

          Get-ChildItem 'bucket' -Filter '*.json' -File | ForEach-Object {
              $file = $_
              $content = Get-Content $file.FullName -Raw -Encoding UTF8
              $originalContent = $content
              $packageName = $file.BaseName

              foreach ($redirect in $redirects.PSObject.Properties) {
                  $parts = $redirect.Name -split ' -> '
                  $oldRepo = $parts[0] -replace 'https://github\.com/', ''
                  $newRepo = $parts[1] -replace 'https://github\.com/', ''

                  # Replace both formats (http and https):
                  # 1. http(s)://github.com/<owner>/<repo>
                  # 2. http(s)://api.github.com/repos/<owner>/<repo>
                  $escapedOldRepo = [regex]::Escape($oldRepo)
                  $oldUrl1 = "https?://github\.com/$escapedOldRepo"
                  $newUrl1 = "https://github.com/$newRepo"
                  $oldUrl2 = "https?://api\.github\.com/repos/$escapedOldRepo"
                  $newUrl2 = "https://api.github.com/repos/$newRepo"

                  $replaced = $false
                  foreach ($url in @($oldUrl1, $oldUrl2)) {
                      if ($content -match $url) {
                          $targetUrl = if ($url -match 'api\.github\.com/repos') { $newUrl2 } else { $newUrl1 }
                          $content = $content -replace $url, $targetUrl
                          Write-Host "$packageName`: replaced URL -> $targetUrl"
                          $replaced = $true
                      }
                  }
                  if ($replaced) {
                      $changedFiles[$packageName] = $true
                  }
              }

              # Only write if content changed
              if ($content -ne $originalContent) {
                  $content | Out-File -FilePath $file.FullName -Encoding UTF8 -NoNewline
              }
          }

          Write-Host "`nTotal files modified: $($changedFiles.Count)."

      - name: Commit and push changes, create/update PR
        shell: pwsh
        working-directory: my_bucket
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Configure git
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # Target branch name
          $targetBranch = "automated-fix-github-redirects"
          $baseBranch = $env:GITHUB_REF_NAME
          Write-Host "Base branch: $baseBranch"

          Write-Host "Working on branch: $targetBranch."

          # Fetch all branches
          Write-Host "Fetching all branches from remote..."
          git fetch --all

          # Check if target branch exists remotely
          $branchExists = git show-ref --verify --quiet "refs/remotes/origin/$targetBranch"

          if ($branchExists) {
              Write-Host "Branch $targetBranch already exists. Checking it out..."
              git checkout $targetBranch
              # Reset to base branch and apply changes (clean slate)
              git reset --hard origin/$baseBranch
          } else {
              Write-Host "Creating new branch $targetBranch from $baseBranch..."
              git checkout origin/$baseBranch -b $targetBranch
          }

          # Check if there are any changes
          $changedFiles = git diff --name-only bucket/
          if ($changedFiles) {
              Write-Host "Found changed files, creating commits..."

              # Get list of changed files
              $files = $changedFiles -split "`n"
              $fileCount = ($files | Where-Object { $_ -match 'bucket/.+\.json' }).Count

              if ($fileCount -eq 1) {
                  # Single file: use package name in commit message
                  foreach ($file in $files) {
                      if ($file -match 'bucket/(.+)\.json') {
                          $packageName = $matches[1]
                          $commitMessage = "$($packageName): Fix GitHub repository redirects"

                          Write-Host "Committing: $commitMessage"
                          git add $file
                          git commit -m $commitMessage
                      }
                  }
              } else {
                  # Multiple files: use generic commit message
                  $commitMessage = $prTitle
                  Write-Host "Committing: $commitMessage"
                  git add bucket/
                  git commit -m $commitMessage
              }

              # Force push to overwrite the branch
              Write-Host "Force pushing changes to $targetBranch..."
              git push origin $targetBranch --force

              # Check if PR already exists (matching title, base/target branches, and bot creator)
              Write-Host "Checking for existing PR..."
              $prCheckHeaders = @{
                  "Authorization" = "Bearer $env:GITHUB_TOKEN"
                  "Accept" = "application/vnd.github.v3+json"
              }
              $repo = $env:GITHUB_REPOSITORY
              $prTitle = "(chore): Fix GitHub repository redirects"
              $prListUrl = "https://api.github.com/repos/$repo/pulls?head=${repo}:${targetBranch}&base=$baseBranch&state=open"
              $prResponse = Invoke-WebRequest -Uri $prListUrl -Method Get -Headers $prCheckHeaders
              $existingPRs = $prResponse.Content | ConvertFrom-Json

              # Get job_id for workflow run URL
              $jobsUrl = "https://api.github.com/repos/$repo/actions/runs/$env:GITHUB_RUN_ID/jobs"
              $jobsResponse = Invoke-WebRequest -Uri $jobsUrl -Method Get -Headers $prCheckHeaders
              $jobsData = $jobsResponse.Content | ConvertFrom-Json
              $currentJob = $jobsData.jobs | Where-Object { $_.name -eq $env:GITHUB_JOB }
              $jobId = if ($currentJob) { $currentJob.id } else { $env:GITHUB_RUN_ID }

              # Find PR matching title and bot creator
              $matchingPR = $existingPRs | Where-Object {
                  $_.title -eq $prTitle -and $_.user.login -eq "github-actions[bot]"
              }

              # Load data for PR description (handle missing files)
              $redirects = @{}
              $unreachable = @()

              if (Test-Path "../redirects.json") {
                  $redirects = Get-Content "../redirects.json" | ConvertFrom-Json
              }

              if (Test-Path "../unreachable.json") {
                  $unreachable = Get-Content "../unreachable.json" | ConvertFrom-Json
              }

              # Build PR description
              $bodyLines = @()
              $motivationLines = @("This automated workflow detected the following GitHub repository redirects:")

              if ($redirects.PSObject.Properties.Count -eq 0 -and $unreachable.Count -eq 0) {
                  $motivationLines += "- No repository redirects or unreachable repositories were detected in this run."
              } else {
                  if ($redirects.PSObject.Properties.Count -gt 0) {
                      $motivationLines += "- **Repository Redirects** ($($redirects.PSObject.Properties.Count) found):"
                      $redirects.PSObject.Properties | ForEach-Object {
                          $parts = $_.Name -split ' -> '
                          $motivationLines += "  - ``$($parts[0])`` → ``$($parts[1])``"
                      }
                  }

                  if ($unreachable.Count -gt 0) {
                      $motivationLines += "- **Unreachable Repositories** ($($unreachable.Count) found):"
                      $unreachable | ForEach-Object {
                          $motivationLines += "  - https://github.com/$_"
                      }
                  }
              }

              $motivationLines += ""
              $motivationLines += "Please review the changes and merge if they look correct."

              $bodyLines += "### Changes"
              $bodyLines += "- $prTitle"
              $bodyLines += ""
              $bodyLines += "### Motivation"
              $bodyLines += $motivationLines
              $bodyLines += ""
              $bodyLines += "---"
              $bodyLines += "<details>"
              $bodyLines += "<summary>Workflow Details (click to expand)</summary>"
              $bodyLines += ""
              $bodyLines += "- Workflow Job: [$env:GITHUB_JOB]($env:GITHUB_SERVER_URL/$env:GITHUB_REPOSITORY/actions/runs/$env:GITHUB_RUN_ID/job/$jobId)"
              $bodyLines += ""
              $bodyLines += "</details>"

              $prBody = $bodyLines -join "`n"

              if ($matchingPR) {
                  # Update existing PR description
                  Write-Host "PR already exists: $($matchingPR.html_url). Updating description..."
                  $updatePRBody = @{
                      body = $prBody
                  } | ConvertTo-Json

                  $updatePRUrl = "https://api.github.com/repos/$repo/pulls/$($matchingPR.number)"
                  $updatePRResponse = Invoke-WebRequest -Uri $updatePRUrl -Method Patch -Headers $prCheckHeaders -Body $updatePRBody
                  Write-Host "PR description updated."
              } else {
                  # Create PR
                  Write-Host "Creating new PR..."
                  $createPRBody = @{
                      title = $prTitle
                      head = $targetBranch
                      base = $baseBranch
                      body = $prBody
                      labels = @("automated")
                  } | ConvertTo-Json

                  $createPRUrl = "https://api.github.com/repos/$repo/pulls"
                  $prCreateResponse = Invoke-WebRequest -Uri $createPRUrl -Method Post -Headers $prCheckHeaders -Body $createPRBody
                  $createdPR = $prCreateResponse.Content | ConvertFrom-Json
                  Write-Host "PR created: $($createdPR.html_url)"
              }
          } else {
              Write-Host "No changes to commit."
          }
